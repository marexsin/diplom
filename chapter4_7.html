<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Глава 1</title>
    <link rel="stylesheet" href="assets/css/styl.css">
</head>
<body>

    <header>
        <img src="assets/images/logomini.png" alt="PostgreSQL Logo" class="logo" height="70px">
        <a href="index.html" class="home-link">Вернуться на главную страницу →</a>
    </header>

  <div class="container">
    <nav class="sidebar">
      <h3>Глава 4. Запросы</h3>
      <ul>
        <li><a href="chapter4.html"> <b> 1. DISTINCT. Выборка уникальных значений</b></a></li>
        <li><a href="chapter4_2.html">2. ORDER BY. Сортировка</a></li>
        <li><a href="chapter4_3.html">3. Получение диапазона строк. LIMIT и OFFSET</a></li>
        <li><a href="chapter4_4.html">4. Операторы фильтрации</a></li>
        <li><a href="chapter4_4.html">5. Агрегатные функции</a></li>
        <li><a href="chapter4_4.html">6. Группировка</a></li>
        <li><a href="chapter4_4.html">7. Подзапросы</a></li>
      </ul>
    </nav>

    <main class="content">
      <h2>Подзапросы</h2>

      <p>
        Подзапросы (subquery) представляют такие запросы, которые могут быть встроены в другие запросы.
      </p>

      <p>Например, определим таблицы для товаров, покупателей и заказов:</p>



      <p>Таблица Orders содержит ссылки на две другие таблицы через поля ProductId и CustomerId.</p>

      <p>Добавим в эти таблицы некоторые данные:</p>


      <p>При добавлении данных в таблицу Orders как раз используются подзапросы. Например, первый заказ был сделан покупателем Tom на товар Galaxy S9. Поэтому в таблицу Orders необходимо сохранить информацию о заказе, где поле ProductId указывает на Id товара Galaxy S9, поле Price - на его цену, а поле CustomerId - на Id покупателя Tom. Но на момент написания запроса нам может быть неизвестен ни Id покупателя, ни Id товара, ни цена товара. В этом случае можно выполнить подзапрос.</p>

      <p>Подзапрос представляет команду SELECT и заключается в скобки. В данном же случае при добавлении одного товара выполняется три подзапроса. Каждый подзапрос возвращает одно скалярное значение, например, идентификатор товара или покупателя.</p>

      <p>В данном случае подзапросы выполнялись к другой таблице, но могут выполняться и к той же, к которой вызывается основной запрос. Например, найдем товары из таблицы Products, которые имеют минимальную цену:</p>



      <p>Или найдем товары, цена которых выше средней:</p>



      <img src="assets/images/postgres4.1_7.png" alt="товары, цена которых выше средней">

      <h3>Коррелирующие подзапросы</h3>

      <p>Подзапросы бывают коррелирующими и некоррелирующими. В примерах выше команды SELECT выполняли фактически один подзапрос для всей команды, например, подзапрос возвращает минимальную или среднюю цену, которая не изменится, сколько бы мы строк не выбирали в основном запросе. Результат такого подзапроса не зависел от строк, которые выбираются в основном запросе. И такой подзапрос выполняется один раз для всего внешнего запроса.</p>

      <p>Но кроме того есть <b>коррелирующие подзапросы</b> (correlated subquery), результаты которых зависят от строк, которые извлекаются в основном запросе.</p>

      <p>Например, выберем все заказы из таблицы Orders, добавив к ним информацию о товаре:</p>



      <p>Здесь для каждой строки из таблицы Orders будет выполняться подзапрос, результат которого зависит от столбца ProductId. И каждый подзапрос может возвращать различные данные.</p>

      <img src="assets/images/postgres4.2_7.png" alt="Каждый подзапрос возвращает различные данные">

      <p>Коррелирующий подзапрос может выполняться и для той же таблицы, к которой выполняется основной запрос. Например, выберем из таблицы Products те товары, стоимость которых выше средней цены товаров для данного производителя:</p>



      <img src="assets/images/postgres4.3_7.png" alt="Товары выше средней цены">

      <p>В данном случае определено два коррелирующих подзапроса. Первый подзапрос определяет спецификацию столбца AvgPrice. Он будет выполняться для каждой строки, извлекаемой из таблицы Products. В подзапрос передается производитель товара и на его основе выбирается средняя цена для товаров именно этого производителя. И так как производитель у товаров может отличаться, то и результат подзапроса в каждом случае также может отличаться.</p>

      <p>Второй подзапрос аналогичен, только он используется для фильтрации извлекаемых из таблицы Products. И также он будет выполняться для каждой строки.</p>

      <p>Чтобы избежать двойственности при фильтрации в подзапросе при сравнении производителей (SubProds.Company=Prods.Company) для внешней выборки установлен псевдоним Prods, а для выборки из подзапросов определен псевдоним SubProds.</p>

    </main>
  </div>

  <div class="button">
    <button class="test" onclick="location.href='test4.html'">ПРОЙТИ ТЕСТ</button>
  </div>

  <div class="transition">
    <button class="next" onclick="location.href='chapter4_6.html'">← Вернуться</button>
    <button class="next" onclick="location.href='chapter5.html'">Дальше →</button>
  </div>

  <footer>
    © 2025 PostgreSQL Учебный Портал. Спасибо, что учитесь с нами!
  </footer>

</body>
</html>